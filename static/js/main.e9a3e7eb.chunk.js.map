{"version":3,"sources":["firebase.ts","store/game/index.ts","store/game/actions.ts","game/Card.tsx","game/Game.tsx","App.tsx","store/index.ts","serviceWorker.ts","index.tsx"],"names":["firebase","initializeApp","apiKey","process","authDomain","databaseURL","projectId","db","firestore","game","createSlice","name","initialState","reducers","setGame","_","action","payload","updateGameState","state","data","Object","fromEntries","entries","map","collection","doc","id","update","actions","watchGame","ref","dispatch","onSnapshot","qs","Card","props","onClick","selected","className","value","selectCard","card","selectedCards","length","concat","matched","cards","setTimeout","matchedCards","FieldValue","arrayUnion","clearSelectedCards","mapDispatch","connector","connect","webId","v","i","key","toString","style","order","indexOf","createGame","type","a","undefined","Array","Math","floor","shuffle","range","random","substr","toUpperCase","padStart","add","loadGame","where","limit","get","empty","docs","maxLength","autoFocus","autoComplete","onChange","e","target","reducer","store","configureStore","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.e9a3e7eb.chunk.js","sourcesContent":["import firebase from 'firebase/app';\nimport 'firebase/firestore';\n\nconst firebaseConfig = {\n  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n  databaseURL: process.env.REACT_APP_FIREBASE_DATABASE_URL,\n  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n};\n\nfirebase.initializeApp(firebaseConfig);\n\nconst db = firebase.firestore();\n\nexport { firebase, db };\n","import { PayloadAction, createSlice } from '@reduxjs/toolkit';\nimport { db } from '../../firebase';\nimport { Game } from '../../models/Game';\nimport { FirestoreUpdateActionPayload } from '../index';\n\nconst game = createSlice({\n  name: 'game',\n  initialState: null as Game | null,\n  reducers: {\n    setGame: (_, action: PayloadAction<Game | null>) => action.payload,\n    updateGameState: (state, action: PayloadAction<FirestoreUpdateActionPayload<Game['state']>>) => {\n      if (state) {\n        const data = Object.fromEntries(Object.entries(action.payload).map(([k, v]) => ['state.' + k, v]));\n        db.collection('games').doc(state.id).update(data);\n      }\n      return state;\n    },\n  },\n});\n\nexport const { setGame, updateGameState } = game.actions;\nexport default game.reducer;\n","import { ThunkAction } from 'redux-thunk';\nimport { range, shuffle } from 'lodash';\nimport { db } from '../../firebase';\nimport { New } from '../../models';\nimport { Game, GameType, MemoryGameProps, MemoryGameState } from '../../models/Game';\nimport { setGame } from '.';\n\n// TOOD: UNSUBSCRIBE WATCHER WHEN REF CHANGES\n\ntype Thunk = ThunkAction<void, any, any, any>;\ntype Ref<T> = firebase.firestore.DocumentReference<T>;\n\nexport function createGame(type: GameType, props?: Game['props']): Thunk {\n  return async dispatch => {\n    if (props === undefined) {\n      props = createGameProps();\n    }\n    const state = createGameState();\n    const webId = Math.random().toString(36).substr(7).toUpperCase().padStart(6, '0'); // TODO: Guarantee uniqueness\n    const game: New<Game> = { type, webId, props, state };\n    const ref = await db.collection('games').add(game) as Ref<Game>;\n    dispatch(watchGame(ref));\n  };\n}\n\nfunction createGameProps(): MemoryGameProps {\n  return {\n    cards: [...Array(24)].map((_, i) => Math.floor(i / 2).toString()),\n    order: shuffle(range(24)),\n  };\n}\n\nfunction createGameState(): MemoryGameState {\n  return {\n    selectedCards: [],\n    matchedCards: [],\n  };\n}\n\nexport function loadGame(webId: Game['webId']): Thunk {\n  return async dispatch => {\n    const qs = await db.collection('games').where('webId', '==', webId).limit(1).get();\n    if (!qs.empty) {\n      const ref = qs.docs[0].ref as Ref<Game>;\n      dispatch(watchGame(ref));\n    }\n  };\n}\n\nexport function watchGame(ref: Ref<Game>): Thunk {\n  return dispatch => {\n    ref.onSnapshot(qs => {\n      const game = qs.data() || null;\n      if (game) {\n        game.id = ref.id;\n      }\n      dispatch(setGame(game));\n    });\n  };\n}\n\nexport { updateGameState } from '.';\n","import React from 'react';\nimport './Card.css';\n\ninterface CardProps {\n  value: string;\n  selected: boolean;\n  onClick: () => void;\n}\n\nconst Card: React.FC<CardProps> = props => (\n  <div onClick={props.onClick}>\n    {props.selected ?\n      <div className=\"Card Card__front\">{props.value}</div> :\n      <div className=\"Card Card__back\"></div>}\n  </div>\n);\n\nexport default Card;\n","import React from 'react';\nimport { Action, ActionCreator } from 'redux';\nimport { connect, ConnectedProps } from 'react-redux';\nimport firebase from 'firebase';\nimport { Game } from '../models/Game';\nimport { FirestoreUpdateActionPayload } from '../store';\nimport { updateGameState } from '../store/game/actions';\nimport './Game.css';\nimport Card from './Card';\n\nfunction selectCard(card: number, game: Game, updateGameState: ActionCreator<Action>) {\n  let { selectedCards } = game.state;\n\n  if (selectedCards.length >= 2) {\n    return;\n  }\n\n  if (card === selectedCards[0]) {\n    selectedCards = [];\n  } else {\n    selectedCards = selectedCards.concat(card);\n  }\n\n  updateGameState({ selectedCards });\n\n  if (selectedCards.length === 2) {\n    const matched = game.props.cards[selectedCards[0]] === game.props.cards[selectedCards[1]];\n    setTimeout(() => clearSelectedCards(matched, selectedCards, updateGameState), 2000);\n  }\n}\n\nfunction clearSelectedCards(matched: boolean, selectedCards: number[], updateGameState: ActionCreator<Action>) {\n  const data: FirestoreUpdateActionPayload<Game['state']> = { selectedCards: [] };\n\n  if (matched) {\n    data.matchedCards = firebase.firestore.FieldValue.arrayUnion(...selectedCards);\n  }\n\n  updateGameState(data);\n}\n\nconst mapDispatch = { updateGameState };\nconst connector = connect(null, mapDispatch);\n\ninterface Props extends ConnectedProps<typeof connector> {\n  game: Game;\n}\n\nconst GameCmp: React.FC<Props> = ({ game, updateGameState }) => (\n  <div className=\"Game\">\n    <div className=\"Game__info\">\n      <h2>Game ID: {game.webId}</h2>\n    </div>\n\n    <div className=\"Game__table\">\n      {game && game.props.cards.map((v: any, i: any) => (\n        <div key={i.toString()} style={{ order: game.props.order[i] }}>\n          {game.state.matchedCards.indexOf(i) === -1 &&\n            <Card value={v} selected={game.state.selectedCards.indexOf(i) > -1}\n              onClick={() => selectCard(i, game, updateGameState)}>\n            </Card>}\n        </div>\n      ))}\n    </div>\n  </div>\n);\n\nexport default connector(GameCmp);\n","import React from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\nimport { RootState } from './store';\nimport { createGame, loadGame } from './store/game/actions';\nimport Game from './game/Game';\nimport './App.css';\n\nconst mapState = ({ game }: RootState) => ({ game });\nconst mapDispatch = { createGame, loadGame };\nconst connector = connect(mapState, mapDispatch);\n\nconst App: React.FC<ConnectedProps<typeof connector>> = ({ game, createGame, loadGame }) => {\n  return (\n    <div className=\"App\">\n      {game ?\n        <Game game={game}></Game> :\n        <div className=\"App__login\">\n          <div className=\"App__login_input\">\n            <h2>Enter your game code:</h2>\n            <input type=\"text\"\n              maxLength={6}\n              autoFocus\n              autoComplete=\"off\"\n              onChange={e => {\n                if (e.target.value.length === 6) {\n                  loadGame(e.target.value.toUpperCase());\n                }\n              }}>\n            </input>\n          </div>\n\n          <div>\n            <a onClick={() => createGame('memory')}><small>Start a new game</small></a>\n          </div>\n        </div>\n      }\n    </div>\n  );\n}\n\nexport default connector(App);\n","import { configureStore } from '@reduxjs/toolkit';\nimport game from './game';\n\nconst reducer = { game };\nconst store = configureStore({ reducer });\n\nexport default store;\n\nexport type FirestoreUpdateActionPayload<T> = Partial<{ [k in keyof T]: T[k] | firebase.firestore.FieldValue }>;\nexport type RootState = ReturnType<typeof store.getState>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport './index.css';\nimport App from './App';\nimport store from './store';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}